#!/usr/bin/env bash

export INPUT_FILE=$(mktemp)
export OUTPUT_FILE=$(mktemp)

if [[ -e $INPUT_FILE ]]; then
  rm $INPUT_FILE
fi 
mkfifo $INPUT_FILE

if [[ -e $OUTPUT_FILE ]]; then
  rm $OUTPUT_FILE
fi
mkfifo $OUTPUT_FILE 

CONTINUE='false'
NAME='UNSET'
JSON='false'
OPTIONS=()
ARGS=()
while [[ $# -gt 0 ]]; do
  case $1 in
    -n)
      NAME=$2
      shift
      shift
      ;;
    -c)
      if [ "$NAME" = 'UNSET' ]; then
        OPTIONS+=($1)
      else
        CONTINUE='true'
      fi
      shift
      ;;
    -j)
      if [ "$NAME" = 'UNSET' ]; then
        OPTIONS+=($1)
      else
        JSON='true'
      fi
      shift
      ;;
    *)
      if [ "$NAME" = 'UNSET' ]; then 
        OPTIONS+=($1)
      else
        ARGS+=($1)
      fi
      shift
      ;;
  esac
done

function output() {
  if [ $JSON = 'true' ]; then
    cat $OUTPUT_FILE | python $(dirname $0)/decode.py | jq
  else
    cat $OUTPUT_FILE
  fi
}

trap 'rm $INPUT_FILE;rm $OUTPUT_FILE;kill $COPROC_PID 2>/dev/null' EXIT
coproc forge script --ffi --sender $ETH_FROM ${OPTIONS[*]} $NAME 1>&2

# This check only works if the script immediately fails
# Does not work for build failures
if ps -p $COPROC_PID > /dev/null; then
  # WARNING: this hangs if the script fails
  # Need to ^C to exit
  read IN <$OUTPUT_FILE 

  if [[ "$CONTINUE" = 'true' || ${#ARGS[@]} -eq 0 ]]; then
    if [[ ! ${#ARGS[@]} -eq 0 ]]; then
      echo "${ARGS[*]}" >$INPUT_FILE
      output
    fi
    echo -n "> "
    while read -r LINE; do
      echo "$LINE" >$INPUT_FILE
      output
      if ! ps -p $COPROC_PID > /dev/null; then
        break
      fi
      echo -n "> "
    done
  else
    echo "${ARGS[*]}" >$INPUT_FILE
    output
  fi
fi
